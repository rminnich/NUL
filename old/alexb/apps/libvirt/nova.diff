diff --git a/configure.ac b/configure.ac
index b12e9fb..3822ee4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -327,6 +327,8 @@ AC_ARG_WITH([remote],
   AC_HELP_STRING([--with-remote], [add remote driver support @<:@default=yes@:>@]),[],[with_remote=yes])
 AC_ARG_WITH([libvirtd],
   AC_HELP_STRING([--with-libvirtd], [add libvirtd support @<:@default=yes@:>@]),[],[with_libvirtd=yes])
+AC_ARG_WITH([nova],
+  AC_HELP_STRING([--with-nova], [add Nova support @<:@default=check@:>@]),[],[with_nova=yes])
 
 dnl
 dnl in case someone want to build static binaries
@@ -537,6 +539,11 @@ if test "$with_test" = "yes" ; then
 fi
 AM_CONDITIONAL([WITH_TEST], [test "$with_test" = "yes"])
 
+if test "$with_nova" = "yes" ; then
+    AC_DEFINE_UNQUOTED([WITH_NOVA], 1, [whether NOVA driver is enabled])
+fi
+AM_CONDITIONAL([WITH_NOVA], [test "$with_nova" = "yes"])
+
 if test "$with_remote" = "yes" ; then
     AC_DEFINE_UNQUOTED([WITH_REMOTE], 1, [whether Remote driver is enabled])
 fi
@@ -2559,6 +2566,7 @@ AC_MSG_NOTICE([xenlight: $with_libxl])
 AC_MSG_NOTICE([     LXC: $with_lxc])
 AC_MSG_NOTICE([    PHYP: $with_phyp])
 AC_MSG_NOTICE([     ESX: $with_esx])
+AC_MSG_NOTICE([    NOVA: $with_nova])
 AC_MSG_NOTICE([ Hyper-V: $with_hyperv])
 AC_MSG_NOTICE([    Test: $with_test])
 AC_MSG_NOTICE([  Remote: $with_remote])
diff --git a/docs/drivers.html b/docs/drivers.html
index be9cfb2..0671d88 100644
--- a/docs/drivers.html
+++ b/docs/drivers.html
@@ -110,6 +110,10 @@
                         <div>
                           <a title="Driver for Microsoft Hyper-V" class="inactive" href="drvhyperv.html">Microsoft Hyper-V</a>
                         </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for NOVA" class="inactive" href="drvnova.html">NOVA</a>
+                        </div>
                       </li></ul>
                   </div>
                 </li><li>
@@ -184,7 +188,7 @@
         <p>
       The hypervisor drivers currently supported by libvirt are:
     </p>
-        <ul><li><strong><a href="drvlxc.html">LXC</a></strong> - Linux Containers</li><li><strong><a href="drvopenvz.html">OpenVZ</a></strong></li><li><strong><a href="drvqemu.html">QEMU</a></strong></li><li><strong><a href="drvtest.html">Test</a></strong> - Used for testing</li><li><strong><a href="drvuml.html">UML</a></strong> - User Mode Linux</li><li><strong><a href="drvvbox.html">VirtualBox</a></strong></li><li><strong><a href="drvesx.html">VMware ESX</a></strong></li><li><strong><a href="drvvmware.html">VMware Workstation/Player</a></strong></li><li><strong><a href="drvxen.html">Xen</a></strong></li><li><strong><a href="drvhyperv.html">Microsoft Hyper-V</a></strong></li></ul>
+    <ul><li><strong><a href="drvlxc.html">LXC</a></strong> - Linux Containers</li><li><strong><a href="drvopenvz.html">OpenVZ</a></strong></li><li><strong><a href="drvqemu.html">QEMU</a></strong></li><li><strong><a href="drvtest.html">Test</a></strong> - Used for testing</li><li><strong><a href="drvuml.html">UML</a></strong> - User Mode Linux</li><li><strong><a href="drvvbox.html">VirtualBox</a></strong></li><li><strong><a href="drvesx.html">VMware ESX</a></strong></li><li><strong><a href="drvvmware.html">VMware Workstation/Player</a></strong></li><li><strong><a href="drvxen.html">Xen</a></strong></li><li><strong><a href="drvhyperv.html">Microsoft Hyper-V</a></strong></li><li><strong><a href="drvnova.html">NOVA</a></strong></li></ul>
         <h2>
           <a name="stroage" id="stroage">Storage drivers</a>
         </h2>
diff --git a/docs/drivers.html.in b/docs/drivers.html.in
index 75038fc..064b714 100644
--- a/docs/drivers.html.in
+++ b/docs/drivers.html.in
@@ -29,6 +29,7 @@
       <li><strong><a href="drvvmware.html">VMware Workstation/Player</a></strong></li>
       <li><strong><a href="drvxen.html">Xen</a></strong></li>
       <li><strong><a href="drvhyperv.html">Microsoft Hyper-V</a></strong></li>
+      <li><strong><a href="drvnova.html">NOVA</a></strong></li>
     </ul>
 
     <h2><a name="stroage">Storage drivers</a></h2>
diff --git a/docs/drvnova.html b/docs/drvnova.html
new file mode 100644
index 0000000..b6ce301
--- /dev/null
+++ b/docs/drvnova.html
@@ -0,0 +1,226 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<!--
+        This file is autogenerated from drvhyperv.html.in
+        Do not edit this file. Changes will be lost.
+      -->
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
+    <link rel="stylesheet" type="text/css" href="main.css" />
+    <link rel="SHORTCUT ICON" href="32favicon.png" />
+    <title>libvirt: Microsoft Hyper-V hypervisor driver</title>
+    <meta name="description" content="libvirt, virtualization, virtualization API" />
+  </head>
+  <body>
+    <div id="header">
+      <div id="headerLogo"></div>
+      <div id="headerSearch">
+        <form action="search.php" enctype="application/x-www-form-urlencoded" method="get"><div>
+            <input id="query" name="query" type="text" size="12" value="" />
+            <input id="submit" name="submit" type="submit" value="Search" />
+          </div></form>
+      </div>
+    </div>
+    <div id="body">
+      <div id="menu">
+        <ul class="l0"><li>
+            <div>
+              <a title="Front page of the libvirt website" class="inactive" href="index.html">Home</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Details of new features and bugs fixed in each release" class="inactive" href="news.html">News</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Applications known to use libvirt" class="inactive" href="apps.html">Applications</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Get the latest source releases, binary builds and get access to the source repository" class="inactive" href="downloads.html">Downloads</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Information for users, administrators and developers" class="active" href="docs.html">Documentation</a>
+              <ul class="l1"><li>
+                  <div>
+                    <a title="How to compile libvirt" class="inactive" href="compiling.html">Compiling</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Information about deploying and using libvirt" class="inactive" href="deployment.html">Deployment</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Overview of the logical subsystems in the libvirt API" class="inactive" href="intro.html">Architecture</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Description of the XML formats used in libvirt" class="inactive" href="format.html">XML format</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Hypervisor specific driver information" class="active" href="drivers.html">Drivers</a>
+                    <ul class="l2"><li>
+                        <div>
+                          <a title="Driver the Xen hypervisor" class="inactive" href="drvxen.html">Xen</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for QEMU, KQEMU, KVM and Xenner" class="inactive" href="drvqemu.html">QEMU / KVM</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for the Linux native container API" class="inactive" href="drvlxc.html">Linux Container</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Pseudo-driver simulating APIs in memory for test suites" class="inactive" href="drvtest.html">Test</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver providing secure remote to the libvirt APIs" class="inactive" href="drvremote.html">Remote</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for the OpenVZ container technology" class="inactive" href="drvopenvz.html">OpenVZ</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for the User Mode Linux technology" class="inactive" href="drvuml.html">UML</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for the storage management APIs" class="inactive" href="storage.html">Storage</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for VirtualBox" class="inactive" href="drvvbox.html">VirtualBox</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for VMware ESX" class="inactive" href="drvesx.html">VMware ESX</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for VMware Workstation / Player" class="inactive" href="drvvmware.html">VMware Workstation / Player</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <a title="Driver for Microsoft Hyper-V" class="inactive" href="drvhyperv.html">Microsoft Hyper-V</a>
+                        </div>
+                      </li><li>
+                        <div>
+                          <span class="active">NOVA</span>
+                        </div>
+                      </li></ul>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Reference manual for the C public API" class="inactive" href="html/index.html">API reference</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Bindings of the libvirt API for other languages" class="inactive" href="bindings.html">Language bindings</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Working on the internals of libvirt API, driver and daemon code" class="inactive" href="internals.html">Internals</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="A guide and reference for developing with libvirt" class="inactive" href="devguide.html">Development Guide</a>
+                  </div>
+                </li><li>
+                  <div>
+                    <a title="Command reference for virsh" class="inactive" href="virshcmdref.html">Virsh Commands</a>
+                  </div>
+                </li></ul>
+            </div>
+          </li><li>
+            <div>
+              <a title="User contributed content" class="inactive" href="http://wiki.libvirt.org">Wiki</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Frequently asked questions" class="inactive" href="http://wiki.libvirt.org/page/FAQ">FAQ</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="How and where to report bugs and request features" class="inactive" href="bugs.html">Bug reports</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="How to contact the developers via email and IRC" class="inactive" href="contact.html">Contact</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Available test suites for libvirt" class="inactive" href="testsuites.html">Test suites</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Miscellaneous links of interest related to libvirt" class="inactive" href="relatedlinks.html">Related Links</a>
+            </div>
+          </li><li>
+            <div>
+              <a title="Overview of all content on the website" class="inactive" href="sitemap.html">Sitemap</a>
+            </div>
+          </li></ul>
+      </div>
+      <div id="content">
+
+    <h1>TU Dresden NOVA OS Virtualization Architecture (NOVA) libvirt driver</h1>
+    <ul id="toc"></ul>
+    <p>
+        The libvirt NOVA driver can be run with NOVA/NUL release 0.5.
+    </p>
+
+
+    <h2><a name="project">Project Links</a></h2>
+    <ul>
+      <li>
+        The <a href="http://www.tudos.org/nul/">NOVA user land</a> homepage
+      </li>
+    </ul>
+
+
+    <h2><a name="uri">Connections to the NOVA driver</a></h2>
+    <p>
+      One example:
+      </p>
+        <pre>
+          nova+tls://192.168.0.13:9999 (TCP/IP + SSL/TLS)
+        </pre>
+        <pre>
+          nova://192.168.0.13:9999 (plain and unencrypted TCP/IP)
+        </pre>
+      <p>
+      <strong>Note</strong>: The NOVA driver is a client side only driver.
+        The
+        <a href="remote.html">remote transport mechanism</a> provided by the
+        remote driver and libvirtd will not work.
+    </p>
+
+
+    <h3><a name="uriformat">URI Format</a></h3>
+    <p>
+        URIs have following general form (<code>[...]</code> marks an optional part).
+        </p>
+          <pre>
+            nova[+tls]://hostname[:port]
+          </pre>
+        <p>
+        The default port is 9999. If the port parameter is given, it
+        overrides the default port.
+    </p>
+
+
+      </div>
+    </div>
+    <div id="footer">
+      <p id="sponsor">
+	    Sponsored by:<br /><a href="http://et.redhat.com/"><img src="et.png" alt="Project sponsored by Red Hat Emerging Technology" /></a></p>
+    </div>
+  </body>
+</html>
diff --git a/docs/drvnova.html.in b/docs/drvnova.html.in
new file mode 100644
index 0000000..d26a6d2
--- /dev/null
+++ b/docs/drvnova.html.in
@@ -0,0 +1,48 @@
+<html><body>
+    <h1>TU Dresden NOVA OS Virtualization Architecture (NOVA) libvirt driver</h1>
+    <ul id="toc"></ul>
+    <p>
+        The libvirt NOVA driver can be run with NOVA/NUL release 0.5.
+    </p>
+
+
+    <h2><a name="project">Project Links</a></h2>
+    <ul>
+      <li>
+        The <a href="http://www.tudos.org/nul/">NOVA user land</a> homepage
+      </li>
+    </ul>
+
+
+    <h2><a name="uri">Connections to the NOVA driver</a></h2>
+    <p>
+      One example:
+      </p>
+        <pre>
+          nova+tls://192.168.0.13:9999 (TCP/IP + SSL/TLS)
+        </pre>
+        <pre>
+          nova://192.168.0.13:9999 (plain and unencrypted TCP/IP)
+        </pre>
+      <p>
+      <strong>Note</strong>: The NOVA driver is a client side only driver.
+        The
+        <a href="remote.html">remote transport mechanism</a> provided by the
+        remote driver and libvirtd will not work.
+    </p>
+
+
+    <h3><a name="uriformat">URI Format</a></h3>
+    <p>
+        URIs have following general form (<code>[...]</code> marks an optional part).
+        </p>
+          <pre>
+            nova[+tls]://hostname[:port]
+          </pre>
+        <p>
+        The default port is 9999. If the port parameter is given, it
+        overrides the default port.
+    </p>
+
+
+</body></html>
diff --git a/examples/domain-events/events-c/event-test.c b/examples/domain-events/events-c/event-test.c
index f4938c4..75869ac 100644
--- a/examples/domain-events/events-c/event-test.c
+++ b/examples/domain-events/events-c/event-test.c
@@ -172,9 +172,9 @@ static int myDomainEventCallback1(virConnectPtr conn ATTRIBUTE_UNUSED,
                                   int detail,
                                   void *opaque ATTRIBUTE_UNUSED)
 {
-    printf("%s EVENT: Domain %s(%d) %s %s\n", __func__, virDomainGetName(dom),
+    printf("%s EVENT: Domain %s(%d) %s %s detail=%x\n", __func__, virDomainGetName(dom),
            virDomainGetID(dom), eventToString(event),
-           eventDetailToString(event, detail));
+           eventDetailToString(event, detail), detail);
     return 0;
 }
 
@@ -420,7 +420,7 @@ int main(int argc, char **argv)
                                                     VIR_DOMAIN_EVENT_CALLBACK(myDomainEventDiskChangeCallback),
                                                     strdup("disk change"), myFreeFunc);
 
-    if ((callback1ret != -1) &&
+    if (//(callback1ret != -1) &&
         (callback2ret != -1) &&
         (callback3ret != -1) &&
         (callback4ret != -1) &&
diff --git a/include/libvirt/virterror.h b/include/libvirt/virterror.h
index e896d67..74631ec 100644
--- a/include/libvirt/virterror.h
+++ b/include/libvirt/virterror.h
@@ -85,6 +85,7 @@ typedef enum {
     VIR_FROM_LOCKING = 42,	/* Error from lock manager */
     VIR_FROM_HYPERV = 43,	/* Error from Hyper-V driver */
     VIR_FROM_CAPABILITIES = 44, /* Error from capabilities */
+    VIR_FROM_NOVA = 45, /* Error from NOVA driver */
 } virErrorDomain;
 
 
diff --git a/src/Makefile.am b/src/Makefile.am
index 0a1221a..b4c970d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -333,6 +333,9 @@ LXC_CONTROLLER_SOURCES =					\
 		lxc/lxc_container.c lxc/lxc_container.h		\
 		lxc/lxc_controller.c
 
+NOVA_DRIVER_SOURCES =						\
+		nova/nova_driver.c nova/nova_driver.h
+
 SECURITY_DRIVER_APPARMOR_HELPER_SOURCES =			\
 		security/virt-aa-helper.c
 
@@ -622,6 +625,21 @@ endif
 libvirt_driver_test_la_SOURCES = $(TEST_DRIVER_SOURCES)
 endif
 
+if WITH_NOVA
+if WITH_DRIVER_MODULES
+mod_LTLIBRARIES += libvirt_driver_nova.la
+else
+noinst_LTLIBRARIES += libvirt_driver_nova.la
+libvirt_la_BUILT_LIBADD += libvirt_driver_nova.la
+endif
+libvirt_driver_nova_la_CFLAGS = \
+		-I@top_srcdir@/src/conf $(AM_CFLAGS)
+if WITH_DRIVER_MODULES
+libvirt_driver_nova_la_LDFLAGS = -module -avoid-version $(AM_LDFLAGS)
+endif
+libvirt_driver_nova_la_SOURCES = $(NOVA_DRIVER_SOURCES)
+endif
+
 if WITH_REMOTE
 if WITH_DRIVER_MODULES
 mod_LTLIBRARIES += libvirt_driver_remote.la
@@ -1116,6 +1134,7 @@ EXTRA_DIST +=							\
 		$(LIBXL_DRIVER_SOURCES)			\
 		$(ESX_DRIVER_SOURCES)				\
 		$(ESX_DRIVER_EXTRA_DIST)			\
+ 		$(NOVA_DRIVER_SOURCES)				\
 		$(HYPERV_DRIVER_SOURCES)			\
 		$(HYPERV_DRIVER_EXTRA_DIST)			\
 		$(NETWORK_DRIVER_SOURCES)			\
@@ -1570,6 +1589,10 @@ if WITH_LIBXL
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/libxl"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/log/libvirt/libxl"
 endif
+if WITH_NOVA
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/nova"
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/nova"
+endif
 if WITH_UML
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/uml"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/uml"
@@ -1616,6 +1639,10 @@ if WITH_LIBXL
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/libxl" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/log/libvirt/libxl" ||:
 endif
+if WITH_NOVA
+	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/nova" ||:
+	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/nova" ||:
+endif
 if WITH_UML
 	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/uml" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/uml" ||:
diff --git a/src/conf/domain_conf.c b/src/conf/domain_conf.c
index 7327667..625d265 100644
--- a/src/conf/domain_conf.c
+++ b/src/conf/domain_conf.c
@@ -89,7 +89,8 @@ VIR_ENUM_IMPL(virDomainVirt, VIR_DOMAIN_VIRT_LAST,
               "vmware",
               "hyperv",
               "vbox",
-              "phyp")
+              "phyp",
+              "nova")
 
 VIR_ENUM_IMPL(virDomainBoot, VIR_DOMAIN_BOOT_LAST,
               "fd",
diff --git a/src/conf/domain_conf.h b/src/conf/domain_conf.h
index cd882bb..79e2efb 100644
--- a/src/conf/domain_conf.h
+++ b/src/conf/domain_conf.h
@@ -58,6 +58,7 @@ enum virDomainVirtType {
     VIR_DOMAIN_VIRT_HYPERV,
     VIR_DOMAIN_VIRT_VBOX,
     VIR_DOMAIN_VIRT_PHYP,
+    VIR_DOMAIN_VIRT_NOVA,
 
     VIR_DOMAIN_VIRT_LAST,
 };
diff --git a/src/conf/domain_event.c b/src/conf/domain_event.c
index 3fd3ed2..f752e1d 100644
--- a/src/conf/domain_event.c
+++ b/src/conf/domain_event.c
@@ -398,6 +398,7 @@ virDomainEventCallbackListAddID(virConnectPtr conn,
     for (i = 0 ; i < cbList->count ; i++) {
         if (cbList->callbacks[i]->cb == VIR_DOMAIN_EVENT_CALLBACK(callback) &&
             cbList->callbacks[i]->eventID == VIR_DOMAIN_EVENT_ID_LIFECYCLE &&
+            (!cbList->callbacks[i]->dom || !dom || memcmp(dom->uuid, cbList->callbacks[i]->dom->uuid, VIR_UUID_BUFLEN) == 0) &&
             cbList->callbacks[i]->conn == conn) {
             eventReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                              _("event callback already tracked"));
diff --git a/src/driver.h b/src/driver.h
index ec4abf3..7cdc05e 100644
--- a/src/driver.h
+++ b/src/driver.h
@@ -30,6 +30,7 @@ typedef enum {
     VIR_DRV_VMWARE = 13,
     VIR_DRV_LIBXL = 14,
     VIR_DRV_HYPERV = 15,
+    VIR_DRV_NOVA
 } virDrvNo;
 
 
diff --git a/src/libvirt.c b/src/libvirt.c
index c288f00..e967e7f 100644
--- a/src/libvirt.c
+++ b/src/libvirt.c
@@ -76,6 +76,9 @@
 # ifdef WITH_XENAPI
 #  include "xenapi/xenapi_driver.h"
 # endif
+# ifdef WITH_NOVA
+#  include "nova/nova_driver.h"
+# endif
 #endif
 
 #define VIR_FROM_THIS VIR_FROM_NONE
@@ -409,7 +412,9 @@ virInitialize(void)
 
     virLogSetFromEnv();
 
+#if WITH_REMOTE
     virNetTLSInit();
+#endif
 
     VIR_DEBUG("register drivers");
 
@@ -454,6 +459,9 @@ virInitialize(void)
 # ifdef WITH_XENAPI
     virDriverLoadModule("xenapi");
 # endif
+# ifdef WITH_NOVA
+    virDriverLoadModule("nova");
+#endif
 # ifdef WITH_REMOTE
     virDriverLoadModule("remote");
 # endif
@@ -485,6 +493,9 @@ virInitialize(void)
 # ifdef WITH_XENAPI
     if (xenapiRegister() == -1) return -1;
 # endif
+# ifdef WITH_NOVA
+    if (novaRegister () == -1) return -1;
+# endif
 # ifdef WITH_REMOTE
     if (remoteRegister () == -1) return -1;
 # endif
diff --git a/src/nova/nova_conf.h b/src/nova/nova_conf.h
new file mode 100644
index 0000000..bb463cb
--- /dev/null
+++ b/src/nova/nova_conf.h
@@ -0,0 +1,35 @@
+/*
+ * Driver to manage VMs running on top of NUL (NOVA user land)
+ * (http://www.tudos.org/nul)
+ *
+ * Copyright (C) 2010-2012 Alexander Boettcher, Operating Systems Group, TU Dresden, Germany
+ *
+ * See COPYING.LIB for the license of this software
+ *
+ * Alexander Boettcher <boettcher@tudos.org>
+ */
+#ifndef __VIR_NOVA_CONF_H__
+# define __VIR_NOVA_CONF_H__
+
+#include <gnutls/gnutls.h>
+#include <gnutls/x509.h>
+
+#include "domain_event.h"
+
+struct nova_conn {
+  int socket_cmd;
+  int socket_event;
+  bool lock_init;
+  bool tls;
+  virDomainEventStatePtr domainEventState;
+  virCapsPtr caps;
+  virThreadPtr eventthread;
+  virMutex lock;
+  gnutls_session_t session_cmd;
+  gnutls_session_t session_event;
+  gnutls_certificate_credentials_t xcred_cmd;
+  gnutls_certificate_credentials_t xcred_event;
+  virDomainObjList domains;
+};
+
+#endif /* __VIR_NOVA_CONF_H__ */
diff --git a/src/nova/nova_driver.c b/src/nova/nova_driver.c
new file mode 100644
index 0000000..191fd9e
--- /dev/null
+++ b/src/nova/nova_driver.c
@@ -0,0 +1,1249 @@
+/*
+ * Driver to manage VMs running on top of NUL (NOVA user land)
+ * (http://www.tudos.org/nul)
+ *
+ * Copyright (C) 2010-2012 Alexander Boettcher, Operating Systems Group, TU Dresden, Germany
+ * Copyright (C) 2011-2012 Michal Sojka, Operating Systems Group, TU Dresden, Germany
+ *
+ * See COPYING.LIB for the license of this software
+ *
+ * Alexander Boettcher <boettcher@tudos.org>
+ * Michal Sojka <sojka@tudos.org>
+ */
+#include <sys/socket.h> //socket
+#include <arpa/inet.h> //inet_pton
+
+#include "virterror_internal.h"
+#include "datatypes.h"
+#include "nova_driver.h"
+#include "buf.h"
+#include "util.h"
+#include "uuid.h"
+#include "capabilities.h"
+#include "memory.h"
+#include "network_conf.h"
+#include "interface_conf.h"
+#include "domain_conf.h"
+#include "domain_event.h"
+#include "event.h"
+#include "storage_conf.h"
+#include "node_device_conf.h"
+#include "xml.h"
+#include "threads.h"
+#include "logging.h"
+#include "limits.h"
+
+#include "nova_types.h"
+#include "nova_conf.h"
+
+#include <fcntl.h>
+
+#include <assert.h>
+#include <sys/stat.h>
+
+#if LIBGNUTLS_VERSION_NUMBER < 0x020a00
+  #define gnutls_certificate_set_verify_function(x, y) while(0){}
+#endif
+
+#define bswap_64(x) ((((x) & 0x00000000000000FFULL) << 56) | \
+                     (((x) & 0x000000000000FF00ULL) << 40) | \
+                     (((x) & 0x0000000000FF0000ULL) << 24) | \
+                     (((x) & 0x00000000FF000000ULL) << 8) | \
+                     (((x) & 0x000000FF00000000ULL) >> 8) | \
+                     (((x) & 0x0000FF0000000000ULL) >> 24) | \
+                     (((x) & 0x00FF000000000000ULL) >> 40) | \
+                     (((x) & 0xFF00000000000000ULL) >> 56))
+#ifdef __APPLE__
+#define be64toh(x) bswap_64(x)
+#define htobe64(x) bswap_64(x)
+#endif
+
+#define VIR_FROM_THIS VIR_FROM_NOVA
+#define NOVA_PROTOCOL_VERSION 0xb001
+static void novaReadEvents(void *data) {
+  virConnectPtr nconn = (virConnectPtr)data;
+  struct nova_conn * conn = (struct nova_conn *)nconn->privateData;
+
+  unsigned char buf[NOVA_PACKET_LEN];
+  int res;
+
+  while(true) {
+    unsigned count = 0;
+    while(count < sizeof(buf)) {
+      if (conn->tls)
+        res = gnutls_record_recv(conn->session_event, buf + count, sizeof(buf) - count);
+      else
+        res = read(conn->socket_event, buf + count, sizeof(buf) - count);
+      if (res < 0) { printf("eventthread - exiting %d\n", res); return; }
+      count += res;
+    }
+
+    struct outgoing_packet * in = (struct outgoing_packet *)buf;
+
+    if (in->version != ntohs(NOVA_PROTOCOL_VERSION)) { fprintf(stderr, "eventthread - version error remote %x != %x ours\n", ntohs(in->version), NOVA_PROTOCOL_VERSION); continue;}
+    if (in->opcode != ntohs(NOVA_EVENT)) { fprintf(stderr, "eventthread - opcode error %x != %x\n", ntohs(in->opcode), NOVA_EVENT ); continue;}
+
+    uint32_t eventid      = *((uint32_t *)(&in->opspecific + 16));
+    uint32_t extra_len    = *((uint32_t *)(&in->opspecific + 16 + sizeof(uint32_t)));
+    unsigned char * extra = &in->opspecific + 16 + 2 * sizeof(uint32_t);
+    virDomainEventPtr event;
+
+    virDomainPtr dom = virDomainLookupByUUID(nconn, &in->opspecific);
+    if (dom) {
+      printf("got event %x %x\n", eventid, ntohl(eventid));
+      if (ntohl(eventid) == EVENT_REBOOT)
+        event = virDomainEventRebootNewFromDom(dom);
+      else
+        event = virDomainEventNewFromDom(dom, ntohl(eventid), ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+    } else {
+      event = virDomainEventNew(-2, "hw", &in->opspecific, ntohl(eventid),
+        ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+      printf("got hw event %p %x\n", event, ntohl(eventid));
+    }
+
+    if (!event) goto cleanup;
+    virDomainEventStateQueue(conn->domainEventState, event);
+
+    cleanup:
+    if (dom) virUnrefDomain(dom);
+  } 
+
+  return; 
+}
+
+/* verify peer's certificate */
+#if LIBGNUTLS_VERSION_NUMBER >= 0x020a00
+static int tls_verify_cert_cb(gnutls_session_t session)
+{
+  int err, i;
+  unsigned int status, cert_list_size;
+  gnutls_x509_crt_t cert;
+  const gnutls_datum_t *cert_list;
+
+ // This verification function uses the trusted CAs in the credentials structure
+  err = gnutls_certificate_verify_peers2 (session, &status);
+  if (err < 0) {
+    gnutls_perror (err);
+    return err;
+  }
+
+  if (status) {
+    if (status & GNUTLS_CERT_INVALID)
+      fprintf (stderr, "The certificate is not trusted.\n");
+    if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)
+      fprintf (stderr, "The certificate hasn't got a known issuer.\n");
+    if (status & GNUTLS_CERT_REVOKED)
+      fprintf (stderr, "The certificate has been revoked.\n");
+    if (status & GNUTLS_CERT_EXPIRED)
+      fprintf (stderr, "The certificate has expired\n");
+    if (status & GNUTLS_CERT_NOT_ACTIVATED)
+      fprintf (stderr, "The certificate is not yet activated\n");
+    return GNUTLS_E_CERTIFICATE_ERROR;
+  }
+
+  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509) return GNUTLS_E_CERTIFICATE_ERROR;
+  if (gnutls_x509_crt_init (&cert) < 0) return GNUTLS_E_CERTIFICATE_ERROR;
+
+  cert_list = gnutls_certificate_get_peers (session, &cert_list_size);
+  if (cert_list == NULL || cert_list_size == 0) return GNUTLS_E_CERTIFICATE_ERROR;
+
+  //XXX check all certificates against trusted CAs list
+  if (gnutls_x509_crt_import (cert, &cert_list[0], GNUTLS_X509_FMT_DER) < 0)
+  {
+    fprintf (stderr, "error parsing certificate\n");
+    return GNUTLS_E_CERTIFICATE_ERROR;
+  }
+
+  struct nova_conn *nconn = gnutls_session_get_ptr (session);
+  if (!nconn) return GNUTLS_E_CERTIFICATE_ERROR;
+
+  char buffer[256];
+  size_t buffer_size;
+  int res = 0;
+  for (i = 0; res >= 0; i++) {
+    buffer_size = sizeof (buffer);
+    res = gnutls_x509_crt_get_subject_alt_name (cert, i, buffer, &buffer_size, NULL);
+
+    if (res == GNUTLS_SAN_IPADDRESS) {
+      struct sockaddr_in addr;
+      bool bchecked = false;
+      //printf("found %s %zd\n", res == GNUTLS_SAN_DNSNAME ? "DNS" : "IPADDRESS", buffer_size);
+      if (buffer_size != 4) return GNUTLS_E_CERTIFICATE_ERROR;
+      //memcpy(&addr.sin_addr, buffer, 4);
+      //printf("remote ip address %s\n", inet_ntoa(addr.sin_addr));
+
+      if (nconn->socket_cmd) {
+        socklen_t addrlen = sizeof(addr);
+        memset(&addr, 0, sizeof(addr));
+        res = getpeername(nconn->socket_cmd, (struct sockaddr *)&addr, &addrlen);
+        if (memcmp(buffer, &addr.sin_addr, 4)) {
+          struct in_addr * tmp = (struct in_addr *)buffer;
+          fprintf(stderr, "IP address in certificate doesn't match ip address of connection (cmd) '%s' !=",
+                 inet_ntoa(*tmp));
+          fprintf(stderr, "'%s'\n", inet_ntoa(addr.sin_addr));
+          return GNUTLS_E_CERTIFICATE_ERROR;
+        }
+        bchecked = true;
+      }
+      if (nconn->socket_event) {
+        socklen_t addrlen = sizeof(addr);
+        memset(&addr, 0, sizeof(addr));
+        res = getpeername(nconn->socket_event, (struct sockaddr *)&addr, &addrlen);
+        if (memcmp(buffer, &addr.sin_addr, 4)) {
+          struct in_addr * tmp = (struct in_addr *)buffer;
+          fprintf(stderr, "IP address in certificate doesn't match ip address of connection (event) '%s' !=",
+                 inet_ntoa(*tmp));
+          fprintf(stderr, "'%s'\n", inet_ntoa(addr.sin_addr));
+          return GNUTLS_E_CERTIFICATE_ERROR;
+        }
+        bchecked = true;
+      }
+      if (!bchecked)
+        return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+    if (res == GNUTLS_SAN_DNSNAME) {
+      fprintf(stderr, "GNUTLS_SAN_DNSNAME check not supported, abort\n");
+      return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+  }
+//  const char * host;
+//  if (!host || !gnutls_x509_crt_check_hostname (cert, host))
+//  {
+//    printf ("The certificate's owner does not match hostname '%s'\n", host ? host : "unknown");
+//    printf ("result %d\n", gnutls_x509_crt_check_hostname (cert, "some.name.com"));
+//    return GNUTLS_E_CERTIFICATE_ERROR;
+//  }
+
+
+  gnutls_x509_crt_deinit (cert);
+
+  return 0; //all ok, continue
+
+}
+#endif // LIBGNUTLS_VERSION_NUMBER >= 0x020a00
+
+static unsigned _create_nova_request(virConnectPtr CONN, unsigned NOVAOPCODE, unsigned char * buf, unsigned nbuf) {
+  struct nova_conn *nconn = (CONN)->privateData;
+  ssize_t res_nova_request;
+  unsigned count_nova_request = 0;
+
+  virMutexLock(&nconn->lock);
+  if (nconn->tls) {
+    if (nbuf != gnutls_record_send(nconn->session_cmd, buf, nbuf)) { res_nova_request = -1; goto request_abort; }
+  } else {
+    if (nbuf != write(nconn->socket_cmd, buf, nbuf)) { res_nova_request = -1; goto request_abort; }
+  }
+  while(count_nova_request < nbuf) {
+    if (nconn->tls) {
+      res_nova_request = gnutls_record_recv(nconn->session_cmd, buf + count_nova_request, nbuf - count_nova_request);
+    } else {
+      res_nova_request = read(nconn->socket_cmd, buf + count_nova_request, nbuf - count_nova_request);
+    }
+    if (res_nova_request < 0) goto request_abort;
+    count_nova_request += res_nova_request;
+  }
+  request_abort:
+  virMutexUnlock(&nconn->lock);
+  if (res_nova_request < 0) return 0;
+
+  struct outgoing_packet * _in = (struct outgoing_packet *)buf;
+
+  if (_in->version != ntohs(NOVA_PROTOCOL_VERSION)) { fprintf(stderr, "version error remote %x != %x ours\n", ntohs(_in->version), NOVA_PROTOCOL_VERSION); return 0; }
+  if (_in->opcode != ntohs(NOVAOPCODE)) { fprintf(stderr, "opcode error\n"); return 0; }
+  if (_in->result != NOVA_OP_SUCCEEDED) {
+    if (_in->result == NOVA_OP_FAILED_OUT_OF_MEMORY)
+      virReportErrorHelper(VIR_FROM_NOVA, VIR_ERR_OPERATION_FAILED, __FILE__,
+                           __FUNCTION__, __LINE__, "out of memory on NOVA host");
+    return 0;
+  }
+
+  return 1;
+}
+
+static virDomainPtr domainLookupByID(virConnectPtr conn, int id);
+
+#define create_nova_request_goto(CONN, NOVAOPCODE, GOTO, CODE) \
+  if (!(CONN)) goto GOTO; \
+\
+  unsigned char buf[NOVA_PACKET_LEN]; \
+  struct incoming_packet * _out = (struct incoming_packet *)buf; \
+\
+  _out->version = htons(NOVA_PROTOCOL_VERSION); \
+  _out->opcode  = htons(NOVAOPCODE); \
+\
+  CODE \
+\
+  if (!_create_nova_request(CONN, NOVAOPCODE, buf, sizeof(buf))) goto GOTO; \
+  ATTRIBUTE_UNUSED struct outgoing_packet * _in = (struct outgoing_packet *)buf
+
+#define create_nova_request(CONN, NOVAOPCODE, ERRORCODE, CODE) \
+  if (!(CONN)) return ERRORCODE; \
+\
+  unsigned char buf[NOVA_PACKET_LEN]; \
+  struct incoming_packet * _out = (struct incoming_packet *)buf; \
+\
+  _out->version = htons(NOVA_PROTOCOL_VERSION); \
+  _out->opcode  = htons(NOVAOPCODE); \
+\
+  CODE \
+\
+  if (!_create_nova_request(CONN, NOVAOPCODE, buf, sizeof(buf))) return ERRORCODE; \
+  ATTRIBUTE_UNUSED struct outgoing_packet * _in = (struct outgoing_packet *)buf
+
+static virDrvOpenStatus novaOpen(virConnectPtr conn,
+                    virConnectAuthPtr auth ATTRIBUTE_UNUSED,
+                    unsigned int flags ATTRIBUTE_UNUSED)
+{
+    int rc, i;
+    struct nova_conn *nconn = 0;
+    bool btls = false;
+    struct {
+      int * socket;
+      int port;
+      gnutls_session_t *session;
+      gnutls_certificate_credentials_t * xcred;
+    } connections [2];
+
+    if (!conn || !conn->uri || !conn->uri->scheme) return VIR_DRV_OPEN_DECLINED;
+
+    if (STREQ(conn->uri->scheme, "nova+tls")) btls = true;
+    if (!btls && STRNEQ(conn->uri->scheme, "nova"))
+      return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->server || !conn->uri->port || conn->privateData)
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (VIR_ALLOC(nconn) < 0) goto error_socket;
+    memset(nconn, 0, sizeof(*nconn));
+    nconn->tls = btls;
+
+    connections[0].socket  = &nconn->socket_cmd;
+    connections[0].port    = conn->uri->port;
+    connections[0].session = &nconn->session_cmd;
+    connections[0].xcred   = &nconn->xcred_cmd;
+    connections[1].socket  = &nconn->socket_event;
+    connections[1].port    = conn->uri->port + 1;
+    connections[1].session = &nconn->session_event;
+    connections[1].xcred   = &nconn->xcred_event;
+
+    for (i=0; i < 2; i++) {
+      struct sockaddr_in addr;
+      addr.sin_family = AF_INET;
+      addr.sin_port = htons(connections[i].port);
+      if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr)) goto error_socket;
+
+      *connections[i].socket = socket(AF_INET, SOCK_STREAM, 0);
+      if (*connections[i].socket < 0) goto error;
+      if (connect(*connections[i].socket, (struct sockaddr *)&addr, sizeof(addr))) goto error_socket;
+
+      // TLS with x509 - start
+      if (btls) {
+        if (gnutls_global_init() != GNUTLS_E_SUCCESS) goto error_socket;
+        if (gnutls_init(connections[i].session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS) goto error_socket;
+
+        /* X509 stuff */
+        if (gnutls_certificate_allocate_credentials(connections[i].xcred) != GNUTLS_E_SUCCESS) goto error_tls_init;
+        /* sets the trusted cas file */
+        //XXX make file name via xml configurable
+
+        if (gnutls_certificate_set_x509_trust_file(*connections[i].xcred, "cacert.pem", GNUTLS_X509_FMT_PEM) <= 0)
+        {
+          char *msg = malloc(PATH_MAX + 20);
+          msg = getcwd(msg, PATH_MAX);
+          strcat(msg, "/cacert.pem");
+          if (errno)
+            perror(msg);
+          else
+            fprintf(stderr, "gnutls_certificate_set_x509_trust_file(%s) error\n", msg);
+          free(msg);
+          goto error_tls_cert;
+        }
+        gnutls_certificate_set_verify_function(*connections[i].xcred, tls_verify_cert_cb);
+#if LIBGNUTLS_VERSION_NUMBER >= 0x020a00
+        gnutls_certificate_set_verify_flags(*connections[i].xcred, GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT);
+#endif
+
+        if (gnutls_priority_set_direct(*connections[i].session, "PERFORMANCE", NULL) != GNUTLS_E_SUCCESS) goto error_tls_cert;
+        if (gnutls_credentials_set(*connections[i].session, GNUTLS_CRD_CERTIFICATE, *connections[i].xcred) != GNUTLS_E_SUCCESS) goto error_tls_cert;
+
+        gnutls_transport_set_ptr (*connections[i].session, (gnutls_transport_ptr_t) *connections[i].socket);
+        gnutls_session_set_ptr (*connections[i].session, nconn);
+
+        if ((rc = gnutls_handshake (*connections[i].session)) < 0) {
+          gnutls_perror (rc);
+          fprintf(stderr, "error handshake %d %d\n", *connections[0].socket, *connections[1].socket);
+          if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED || rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {
+            gnutls_alert_description_t alert = gnutls_alert_get(*connections[i].session);
+            fprintf(stderr, "%s alert: (%d) %s\n", rc == GNUTLS_E_WARNING_ALERT_RECEIVED ? "warning" : "fatal", alert, gnutls_alert_get_name(alert));
+          }
+          goto error;
+        }
+      }
+      // TLS - end
+    }
+
+    if (!(nconn->domainEventState = virDomainEventStateNew())) goto error;
+    if (!(nconn->caps = virCapabilitiesNew("i686", 0, 0))) goto error;
+    if (!(virCapabilitiesAddGuest(nconn->caps, "hvm", "i686", 32, NULL, NULL, 0, NULL))) goto error;
+    if (virDomainObjListInit(&nconn->domains)) goto out_of_memory;
+
+    conn->privateData = nconn;
+
+    {
+      create_nova_request_goto(conn, NOVA_AUTH, error, {
+        uint32_t *t_authid_len = (uint32_t *) &_out->opspecific;
+        *t_authid_len = htonl(strlen("Hello") + 1);
+        char * t_authid = ((char *)(t_authid_len)) + sizeof(*t_authid_len);
+        memcpy(t_authid, "Hello", ntohl(*t_authid_len));
+      });
+    }
+
+    if (VIR_ALLOC(nconn->eventthread) < 0) goto error; 
+    if (virMutexInit(&nconn->lock) < 0) goto error;
+    else nconn->lock_init = true;
+    if (virThreadCreate(nconn->eventthread, true, novaReadEvents, conn)) goto error;
+
+    return VIR_DRV_OPEN_SUCCESS;
+
+    /* error handling */
+    out_of_memory:
+    virReportOOMError();
+
+    error:
+    if (btls) {
+      gnutls_bye(nconn->session_cmd, GNUTLS_SHUT_WR);
+      if (i > 0) gnutls_bye(nconn->session_event, GNUTLS_SHUT_WR);
+    }
+
+    error_tls_cert:
+    if (btls) {
+      gnutls_certificate_free_credentials (nconn->xcred_cmd);
+      if (i > 0) gnutls_certificate_free_credentials (nconn->xcred_event);
+    }
+
+    error_tls_init:
+    if (btls) {
+      gnutls_deinit (nconn->session_cmd);
+      if (i > 0) gnutls_deinit (nconn->session_event);
+    }
+
+    error_socket:
+    if (nconn) virDomainObjListDeinit(&nconn->domains);
+    if (nconn && nconn->caps) virCapabilitiesFree(nconn->caps);
+    if (nconn && nconn->domainEventState) virDomainEventStateFree(nconn->domainEventState);
+    if (nconn && nconn->eventthread) VIR_FREE(nconn->eventthread);
+    if (nconn && nconn->lock_init) virMutexDestroy(&nconn->lock);
+    if (*connections[0].socket) close(*connections[0].socket);
+    if (*connections[1].socket) close(*connections[1].socket);
+    if (nconn) VIR_FREE(nconn);
+
+    return VIR_DRV_OPEN_ERROR;
+}
+
+static int novaClose(virConnectPtr conn)
+{
+    int res;
+    struct nova_conn *nconn;
+
+    if (!(nconn = conn->privateData)) return -1;
+    
+    if (nconn->tls) {
+      gnutls_bye(nconn->session_cmd, GNUTLS_SHUT_WR);
+      gnutls_bye(nconn->session_event, GNUTLS_SHUT_WR);
+    }
+
+    if (nconn->eventthread) {
+      virThreadJoin(nconn->eventthread);
+      VIR_FREE(nconn->eventthread);
+    }
+
+    virMutexLock(&nconn->lock);
+    virDomainObjListDeinit(&nconn->domains);
+    virMutexUnlock(&nconn->lock);
+
+    if (nconn->domainEventState) virDomainEventStateFree(nconn->domainEventState);
+    if (nconn->caps)    virCapabilitiesFree(nconn->caps);
+
+    if (nconn->tls) { //call free/deinit here - after event thread passed away (otherwise segfault may happen)
+      gnutls_certificate_free_credentials (nconn->xcred_cmd);
+      gnutls_certificate_free_credentials (nconn->xcred_event);
+      gnutls_deinit (nconn->session_cmd);
+      gnutls_deinit (nconn->session_event);
+    }
+
+    res = close(nconn->socket_cmd);
+    printf("nova - %s - closing mgmt connection ...\n", res ? "failure" : "success");
+    res = close(nconn->socket_event);
+    printf("nova - %s - closing event connection ...\n", res ? "failure" : "success");
+
+
+    if (nconn->lock_init) virMutexDestroy(&nconn->lock);
+    memset(nconn, 0, sizeof(*nconn));
+    VIR_FREE(nconn);
+    conn->privateData = 0;
+
+    return res;
+}
+
+#define dump_uuid(uuid2) \
+  printf("%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", \
+    uuid2[0] & 0xff, uuid2[1] & 0xff, uuid2[2] & 0xff, uuid2[3] & 0xff, \
+    uuid2[4] & 0xff, uuid2[5] & 0xff, uuid2[6] & 0xff, uuid2[7] & 0xff, \
+    uuid2[8] & 0xff, uuid2[9] & 0xff, uuid2[10]& 0xff, uuid2[11]& 0xff, \
+    uuid2[12]& 0xff, uuid2[13]& 0xff, uuid2[14]& 0xff, uuid2[15]& 0xff);
+
+static int createDef(virConnectPtr conn, char const * name, unsigned name_len,
+                     unsigned char const uuid[VIR_UUID_BUFLEN],
+                     virDomainInfoPtr info)
+{
+  virDomainDefPtr def;
+  virDomainObjPtr vm;
+  char * xml;
+  char const xml1[] = "<domain type='nova'> <name>";
+  char const xml2[] = "</name> <uuid>00000000-0000-0000-0000-000000000000</uuid> <memory>000128000</memory>"
+                      "<currentMemory>000128000</currentMemory> <os> <type arch='i686'>hvm</type> </os> </domain>";
+  struct nova_conn *nconn = conn->privateData;
+
+  if (virAlloc(&xml, sizeof(xml1) + sizeof(xml2) + name_len - 1)) return -1;
+
+  memcpy(xml, xml1, sizeof(xml1));
+  memcpy(xml+sizeof(xml1) - 1, name, name_len);
+  memcpy(xml+sizeof(xml1) - 1 + name_len, xml2, sizeof(xml2));
+
+  // uuid replacement
+  char * n_uuid = strstr(xml, "<uuid>");
+  assert(n_uuid);
+  n_uuid += 6;
+  for (unsigned i=0; i < 16; i++) {
+    sprintf(n_uuid, "%02x", uuid[i] & 0xff);
+    n_uuid += 2;
+    if (i == 3 || i == 5 || i == 7 || i == 9) *n_uuid++ = '-';
+  }
+  *n_uuid = '<';
+
+  // memory replacement
+  if (info) {
+    n_uuid = strstr(xml, "<memory>");
+    assert(n_uuid);
+    sprintf(n_uuid + 8, "%09lu", info->maxMem);
+    n_uuid[8 + 9] = '<';
+    n_uuid = strstr(xml, "<currentMemory>");
+    assert(n_uuid);
+    sprintf(n_uuid + 15, "%09lu", info->memory);
+    n_uuid[15 + 9] = '<';
+  }
+  xml[sizeof(xml1) + name_len + sizeof(xml2) - 2] = 0;
+
+  def = virDomainDefParseString(nconn->caps, xml, 1 << VIR_DOMAIN_VIRT_NOVA, VIR_DOMAIN_XML_INACTIVE);
+  if (!def) { fprintf(stderr, "failure - parsing VM xml : \n %s\n", xml); return -1; }
+
+  virMutexLock(&nconn->lock);
+  vm = virDomainAssignDef(nconn->caps, &nconn->domains, def, false);
+  virMutexUnlock(&nconn->lock);
+  if (!vm) {
+    virDomainDefFree(def);
+    return -1;
+  }
+
+  assert(!memcmp(vm->def->name, name, name_len));
+  assert(!memcmp(vm->def->uuid, uuid, 16));
+  virDomainObjUnlock(vm);
+  return 0;
+}
+
+static int nodeGetInfo(virConnectPtr conn, virNodeInfoPtr info) {
+  create_nova_request(conn, NOVA_HW_INFO, -1, {});
+
+  uint32_t * data = (uint32_t *)&_in->opspecific;
+  info->memory = ntohl(*data++); info->cpus = ntohl(*data++);
+  info->mhz = ntohl(*data++); info->nodes = ntohl(*data++);
+  info->sockets = ntohl(*data++); info->cores = ntohl(*data++);
+  info->threads = ntohl(*data++);
+  memcpy(info->model, data, 13);
+  return 0;
+}
+
+static int numOfDomains(virConnectPtr conn) {
+
+  create_nova_request(conn, NOVA_NUM_OF_ACTIVE_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+  return res;
+}
+
+static bool atomicrules(virConnectPtr conn, virDomainPtr dom, const char *xml) {
+
+  if (dom->id <= 0) return false;
+
+  xmlDocPtr xmltest;
+  xmltest = virXMLParseString(xml, "nova stuff");
+  if (!xmltest) return false;
+
+  xmlNodePtr domain_root = xmlDocGetRootElement(xmltest);
+  if (!domain_root) return NULL;
+
+//  printf("root name '%s' '%s' count=%lu\n", domain_root->name, xmlGetNodePath(domain_root), xmlChildElementCount(domain_root));
+  xmlNodePtr test_tmp = xmlFirstElementChild (domain_root);
+  while (test_tmp) {
+  //  printf("node name '%s' childs %lu\n", test_tmp->name, xmlChildElementCount(domain_root));
+    if (xmlStrEqual(test_tmp->name, (const unsigned char *)"atomicrules")) {
+        xmlNodePtr atomic_rule = xmlFirstElementChild(test_tmp);
+        while (atomic_rule) {
+		      char * xml_eventid  = xmlGetProp(atomic_rule, (const unsigned char *)"eventid");
+		      char * xml_actionid = xmlGetProp(atomic_rule, (const unsigned char *)"action");
+          if (!xml_eventid || !xml_actionid) return false;
+          printf("rule eventid=%s actionid=%s %d\n", xml_eventid, xml_actionid, dom->id);
+
+          {
+            create_nova_request(conn, NOVA_ENABLE_EVENT, false,
+            {
+              uint32_t * out_id = (uint32_t *)&_out->opspecific;
+              *out_id = htonl(dom->id);
+              *(out_id + 1) = htonl(strtoul(xml_eventid, 0, 10));
+            });
+          }
+          create_nova_request(conn, NOVA_ATOMIC_RULE, false,
+          {
+            uint32_t * out_id = (uint32_t *)&_out->opspecific;
+            *out_id = htonl(dom->id);
+            *(out_id + 1) = htonl(strtoul(xml_eventid, 0, 10));
+            *(out_id + 2) = htonl(strtoul(xml_actionid, 0, 10));
+          });
+          atomic_rule = xmlNextElementSibling (atomic_rule);
+        }
+    }
+    test_tmp = xmlNextElementSibling (test_tmp);
+  }
+  return true;
+}
+
+static virDomainPtr domainCreateXML(virConnectPtr conn,
+                                    const char *xml,
+                                    unsigned int flags)
+{
+  if (!conn || !xml || flags != VIR_DOMAIN_NONE) return NULL;
+
+  virDomainDefPtr def;
+  virDomainObjPtr vm = NULL;
+  virDomainPtr dom = NULL;
+  bool live = false;
+  struct nova_conn *n_conn = conn->privateData;
+  int fd, sock;
+  struct sockaddr_in addr;
+  ssize_t read_in = 2048;
+  ssize_t send_out;
+  char buffer[read_in];
+  int id;
+
+  if (!(def = virDomainDefParseString(n_conn->caps, xml, 1 << VIR_DOMAIN_VIRT_NOVA, VIR_DOMAIN_XML_INACTIVE))) return NULL;
+
+  // disk handling
+  if (def->ndisks <= 0 || !def->disks ||
+      def->disks[0]->type != VIR_DOMAIN_DISK_TYPE_FILE) goto def_cleanup;
+
+//  Logging::printf("\n", def->disks[0]->auth-);
+  struct stat st;
+  fd = open(def->disks[0]->src, 0);
+  if (fd < 0) {
+    fprintf(stderr, "error getting image, current dir is %s\n", getcwd(def->disks[0]->src, strlen(def->disks[0]->src)));
+    goto def_cleanup;
+  }
+  if (stat(def->disks[0]->src, &st)) goto file_cleanup;
+
+  // create VM
+  virMutexLock(&n_conn->lock);
+  vm = virDomainAssignDef(n_conn->caps, &n_conn->domains, def, live);
+  virMutexUnlock(&n_conn->lock);
+  if (!vm) goto file_cleanup;
+
+//  printf("start name=%s memory=%lu ndisk=%d disk->%p src=%s dst=%s\n", def->name, def->mem.max_balloon, def->ndisks, def->disks, def->disks[0]->src, def->disks[0]->dst);
+  {
+    create_nova_request_goto(conn, NOVA_VM_START, file_cleanup, {
+      char * uuid = (char *)&_out->opspecific;
+      memcpy(uuid, vm->def->uuid, VIR_UUID_BUFLEN);
+      uint32_t *mem = (uint32_t *) (uuid + VIR_UUID_BUFLEN);
+      *mem = htonl(def->mem.max_balloon);
+      uint32_t *len = (uint32_t *) (uuid + VIR_UUID_BUFLEN + sizeof(*mem));
+      *len = htonl(strlen(vm->def->name));
+      uint64_t *file_size = (uint64_t *) (uuid + VIR_UUID_BUFLEN + sizeof(*len) + sizeof(*mem));
+      *file_size = htobe64(st.st_size);
+      char * name = uuid + VIR_UUID_BUFLEN + sizeof(*len) + sizeof(*mem) + sizeof(*file_size);
+      memcpy(name, vm->def->name, ntohl(*len));
+    });
+    uint32_t * _op = (uint32_t *)&_in->opspecific;
+    id = ntohl(*_op);
+  }
+  virDomainObjUnlock(vm);
+  vm = NULL;
+
+  if (id) {
+    dom = domainLookupByID(conn, id);
+    if (!dom) goto file_cleanup;
+  } else goto file_cleanup;
+
+  if (!atomicrules(conn, dom, xml)) goto file_cleanup;
+
+  //upload hack
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(10043);
+  if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr)) goto file_cleanup;
+
+  sock = socket(AF_INET, SOCK_STREAM, 0);
+  if (sock < 0) goto def_cleanup;
+  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr))) goto socket_cleanup;
+
+  {
+    uint64_t file_size = st.st_size;
+    uint64_t parts = file_size / 70;
+    uint64_t sent = 0, next = parts;
+
+    struct tmp {
+      char uuid[VIR_UUID_BUFLEN];
+      uint32_t diskid;
+      uint64_t size;
+    } ATTRIBUTE_PACKED * tmp = (struct tmp *)buffer;
+    memcpy(tmp->uuid, dom->uuid, VIR_UUID_BUFLEN);
+    tmp->diskid = htonl(0); //XXX
+    tmp->size = htobe64(file_size);
+    if (sizeof(*tmp) != send(sock, buffer, sizeof(*tmp), 0)) goto socket_cleanup;
+
+    printf("file size %lu\n[", file_size);
+    fflush(stdout);
+    while (read_in == sizeof(buffer)) {
+      read_in = read(fd, buffer, sizeof(buffer));
+      if (read_in < 0) { printf("send error %lu\n", read_in); goto socket_cleanup; }
+      //printf("%lu->", read_in);
+      send_out = send(sock, buffer, read_in, 0);
+      //printf("%lu ", send_out);
+      if (send_out > 0) sent += send_out;
+      if (sent > next) {
+        printf("=> %3lu%%\033[6D", sent * 100 / file_size);
+        fflush(stdout);
+        next += parts;
+      }
+      if (send_out != read_in) { printf("error in sending\n"); goto socket_cleanup; }
+    }
+    read_in = recv(sock, buffer, 20, 0); //XXX check for errors
+    printf(">] - sha1: ");
+    for (unsigned j=0; j < 20; j++) {
+      printf("%02x", buffer[j] & 0xff);
+    }
+    printf("\n");
+    close(fd);
+    close(sock);
+  }
+
+  {
+    struct nova_conn * nconn = (struct nova_conn *)conn->privateData;
+    virDomainEventPtr event;
+    event = virDomainEventNewFromDom(dom, VIR_DOMAIN_EVENT_STARTED, VIR_DOMAIN_EVENT_STARTED_BOOTED);
+    if (!event) return NULL;
+    virDomainEventStateQueue(nconn->domainEventState, event);
+  }
+  return dom;
+
+  socket_cleanup:
+  close(sock);
+
+  file_cleanup:
+  close(fd);
+
+  def_cleanup:
+  if (vm)  virDomainObjUnlock(vm);
+  else
+    if (dom) virUnrefDomain(dom);
+    else  virDomainDefFree(def);
+
+  return NULL;
+}
+
+static char *getCapabilities(virConnectPtr conn ATTRIBUTE_UNUSED) {
+  const char cap[] = \
+  "<host>" \
+   "<cpu>" \
+     "<arch>i686</arch" \
+   "</cpu>" \
+  "</host>" \
+  "<guest>" \
+   "<os_type>hvm</os_type>" \
+   "<arch name=""i686"">" \
+     "<wordsize>32</wordsize>" \
+   "</arch>" \
+   "<features/>" \
+  "</guest>";
+  char * tmp;
+  if (-1 == virAlloc(&tmp, sizeof(cap))) return 0;
+  else memcpy(tmp, cap, sizeof(cap));
+  return tmp;
+}
+
+static int listDomains (virConnectPtr conn,
+                            int *ids,
+                            int maxids)
+{
+  create_nova_request(conn, NOVA_LIST_ACTIVE_DOMAINS, -1, {});
+
+  unsigned i;
+  uint32_t * _ids  = (uint32_t *)&_in->opspecific;
+  uint32_t _maxids = ntohl(*_ids);
+
+  _ids++;
+
+  uint32_t max = _maxids < maxids ? _maxids : maxids;
+
+  for (i=0; i < max; i++) {
+    *ids = ntohl(*_ids);
+    ids++;
+    _ids++; 
+  }
+
+  return max;
+}
+
+static int numOfDefinedDomains(virConnectPtr conn) {
+  create_nova_request(conn, NOVA_NUM_OF_DEFINED_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+
+  return res;
+}
+
+static int _domainGetInfo (virConnectPtr conn,
+                           unsigned char const uuid[VIR_UUID_BUFLEN],
+                           virDomainInfoPtr info)
+{
+  create_nova_request(conn, NOVA_GET_VM_INFO, -1, {
+    memcpy(&_out->opspecific, uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * memory = (uint32_t *)&_in->opspecific;
+  uint32_t * vcpus  = (uint32_t *)(&_in->opspecific + sizeof(uint32_t));
+  uint64_t * t_cpu  = (uint64_t *)(&_in->opspecific + 2*sizeof(uint32_t));
+  uint32_t * state  = (uint32_t *)(&_in->opspecific + 2*sizeof(uint32_t) + sizeof(uint64_t));
+
+  info->state     = ntohl(*state);
+  info->maxMem    = ntohl(*memory);  // the maximum memory in KBytes allowed
+  info->memory    = ntohl(*memory);  // the memory in KBytes used by the domain
+  info->nrVirtCpu = ntohl(*vcpus);   // the number of virtual CPUs for the domain
+  info->cpuTime   = be64toh(*t_cpu) * 1000; // get in microseconds - time used in nanoseconds
+
+  return 0;
+}
+
+static int domainGetInfo (virDomainPtr domain,
+                          virDomainInfoPtr info)
+{
+  if (!info || !domain || !domain->conn) return -1;
+  int res =  _domainGetInfo (domain->conn, domain->uuid, info);
+  if (res) return res;
+
+  if (domain->id == -1) // XXX 
+    info->state  = VIR_DOMAIN_NOSTATE;
+  return res;
+}
+
+#define domainLookupByhandling(CONN, IDID) \
+  struct nova_conn *nconn = (CONN)->privateData; \
+  virMutexLock(&nconn->lock); \
+  virDomainObjPtr vm = virDomainFindByUUID(&nconn->domains, uuid); \
+  virMutexUnlock(&nconn->lock); \
+\
+  if (!vm) { \
+    virDomainInfo info; \
+    int err = _domainGetInfo (conn, uuid, &info); \
+    if (err) return NULL; \
+    err = createDef(conn, name, strlen(name), uuid, &info); \
+    assert(!err); \
+  } else \
+    virDomainObjUnlock(vm); \
+\
+  virDomainPtr res = virGetDomain(conn, name, uuid); \
+  if (res) res->id = (IDID); \
+\
+  return res
+
+static virDomainPtr domainLookupByUUID(virConnectPtr conn,
+                                       const unsigned char *uuid)
+{
+  create_nova_request(conn, NOVA_GET_NAME_UUID, NULL, 
+    {
+      memcpy(&_out->opspecific, uuid, VIR_UUID_BUFLEN);
+    });
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+  char const * name = (char const *)(&_in->opspecific + sizeof(*_op));
+
+  domainLookupByhandling(conn, id);
+}
+
+static virDomainPtr domainLookupByID(virConnectPtr conn, int id)
+{
+  create_nova_request(conn, NOVA_GET_NAME_ID, NULL, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(id);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * name = (char const *)(&_in->opspecific + 16);
+
+  domainLookupByhandling(conn, id);
+}
+
+static int cloneDef(virConnectPtr conn, virDomainDefPtr cpy,
+                     unsigned char uuid[VIR_UUID_BUFLEN])
+{
+  virDomainDefPtr def;
+  virDomainObjPtr vm;
+  struct nova_conn *nconn = conn->privateData;
+
+  char * xml = virDomainDefFormat(cpy, VIR_DOMAIN_XML_SECURE);
+  if (!xml) return -1;
+
+  char * n_uuid = strstr(xml, "<uuid>");
+  assert(n_uuid);
+  n_uuid += 6;
+  for (unsigned i=0; i < 16; i++) {
+    sprintf(n_uuid, "%02x", uuid[i] & 0xff);
+    n_uuid += 2;
+    if (i == 3 || i == 5 || i == 7 || i == 9) *n_uuid++ = '-';
+  }
+  *n_uuid = '<';
+
+  def = virDomainDefParseString(nconn->caps, xml, 1 << VIR_DOMAIN_VIRT_NOVA, VIR_DOMAIN_XML_INACTIVE);
+  assert(def);
+
+  VIR_FREE(xml);
+
+  vm = virDomainAssignDef(nconn->caps, &nconn->domains, def, false);
+  assert(vm);
+  virDomainObjUnlock(vm);
+
+  return 0;
+}
+
+static int domainCreate(virDomainPtr domain) {
+  if (!domain || domain->id != -1) return -1; //XXX only predefined vms are startable currently 
+
+  unsigned char _uuid[VIR_UUID_BUFLEN];
+  if (-1 == virUUIDGenerate(_uuid)) return -1;
+
+  struct nova_conn *conn = domain->conn->privateData;
+
+  virMutexLock(&conn->lock);
+  virDomainObjPtr vm = virDomainFindByUUID(&conn->domains, domain->uuid);
+  assert(vm);
+  int err = cloneDef(domain->conn, vm->def, _uuid);
+  virDomainObjUnlock(vm);
+  virMutexUnlock(&conn->lock);
+  if (err) return err; //XXX
+
+  create_nova_request(domain->conn, NOVA_VM_START, -1, {
+    char * uuid = (char *)&_out->opspecific;
+    memcpy(uuid, domain->uuid, VIR_UUID_BUFLEN);
+    uuid += VIR_UUID_BUFLEN;
+    memcpy(uuid, _uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+
+  if (id) {
+    domain->id = id;
+
+    virDomainEventPtr event;
+    event = virDomainEventNewFromDom(domain, VIR_DOMAIN_EVENT_STARTED, VIR_DOMAIN_EVENT_STARTED_BOOTED);
+    if (!event) return -1;
+    virDomainEventStateQueue(conn->domainEventState, event);
+
+  } else return -1;
+  return 0;
+}
+
+static int domainSuspend(virDomainPtr domain) {
+  if (!domain || domain->id == -1 || !domain->conn) return 0;
+
+  create_nova_request(domain->conn, NOVA_VM_PAUSE, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  virDomainEventPtr event;
+  event = virDomainEventNewFromDom(domain, VIR_DOMAIN_EVENT_SUSPENDED, VIR_DOMAIN_EVENT_SUSPENDED_PAUSED);
+  if (!event) return -1;
+  struct nova_conn *nconn = domain->conn->privateData;
+  virDomainEventStateQueue(nconn->domainEventState, event);
+
+  return 0;
+}
+
+static int domainResume(virDomainPtr domain) {
+  if (!domain || domain->id == -1 || !domain->conn) return 0;
+
+  create_nova_request(domain->conn, NOVA_VM_RESUME, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  virDomainEventPtr event;
+  event = virDomainEventNewFromDom(domain, VIR_DOMAIN_EVENT_RESUMED, VIR_DOMAIN_EVENT_RESUMED_UNPAUSED);
+  if (!event) return -1;
+  struct nova_conn *nconn = domain->conn->privateData;
+  virDomainEventStateQueue(nconn->domainEventState, event);
+
+  return 0;
+}
+
+static int domainIsPersistent(virDomainPtr dom) {
+  if (!dom) return -1;
+
+  if (dom->id == -1) return 1; //XXX fix it - guessing
+  return 0;
+}
+
+static int domainEventRegisterAny(virConnectPtr conn, 
+  virDomainPtr dom, int eventID, virConnectDomainEventGenericCallback cb,
+  void * opaque, virFreeCallback freecb) //XXX currently no registry per event possible, all or nothing for all domains or just for a specific
+{
+  int res;
+
+  create_nova_request(conn, NOVA_ENABLE_EVENT, -1, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      if (dom)
+        *out_id = htonl(dom->id);
+      else
+        *out_id = htonl(-1);
+      *(out_id + 1) = htonl(eventID);
+    });
+
+  struct nova_conn *nconn = conn->privateData;
+  if (1 > virDomainEventStateRegisterID(conn, nconn->domainEventState,
+                                        dom, eventID, cb, opaque, freecb, &res))
+    return -1;
+  return res;
+}
+
+static int domainEventDeregisterAny(virConnectPtr conn, int callbackID)
+{
+  create_nova_request(conn, NOVA_DISABLE_EVENT, -1,
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(-1);
+    });
+ 
+  struct nova_conn *nconn = conn->privateData;
+  return virDomainEventStateDeregisterID(conn, nconn->domainEventState, callbackID);
+}
+
+static char *domainGetXMLDesc(virDomainPtr domain, unsigned int flags)
+{
+  if (!domain || !domain->conn || !domain->conn->privateData) return 0;
+
+  struct nova_conn *nconn = domain->conn->privateData;
+
+  virMutexLock(&nconn->lock);
+  virDomainObjPtr vm = virDomainFindByUUID(&nconn->domains, domain->uuid);
+  virMutexUnlock(&nconn->lock);
+  if (!vm) return 0;
+
+  char * xml = virDomainDefFormat(vm->def, flags);
+  virDomainObjUnlock(vm);
+  return xml;
+}
+
+static int listDefinedDomains(virConnectPtr conn, char ** const names, int maxnames)
+{
+  unsigned i;
+  char * out;
+
+  create_nova_request(conn, NOVA_LIST_DEFINED_DOMAINS, -1, {
+      uint32_t * max = (uint32_t *)&_out->opspecific;
+      *max = htonl(maxnames);
+    });
+
+  uint32_t * _num = (uint32_t *)&_in->opspecific;
+  uint32_t    num = ntohl(*_num);
+  char     * name = (char *)(&_in->opspecific + 4);
+
+  for (i=0; i < num; i++) {
+    uint32_t len   = strlen(name) + 1;
+  
+    if (-1 == virAlloc(&out, len)) return -1;
+    memcpy(out, name, len);
+    names[i] = out;
+    name += len;
+  }
+
+  return num;
+}
+
+static virDomainPtr domainLookupByName(virConnectPtr conn, const char * name)
+{
+  create_nova_request(conn, NOVA_GET_NAME, NULL,
+    {
+      if (strlen(name) + 1 > NOVA_PACKET_LEN - (&_out->opspecific - buf)) return NULL;
+      memcpy(&_out->opspecific, name, strlen(name) + 1);
+    });
+
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * _name = (char const *)(&_in->opspecific + 16);
+
+  if (memcmp(name, _name, strlen(name) + 1)) return NULL;
+
+  domainLookupByhandling(conn, -1);
+}
+
+static int domainDestroy (virDomainPtr domain)
+{
+  if (!domain || domain->id == -1) return -1;
+
+  create_nova_request(domain->conn, NOVA_VM_DESTROY, -1, {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(domain->id);
+  });
+
+  struct nova_conn *nconn = domain->conn->privateData;
+  virMutexLock(&nconn->lock);
+  virDomainObjPtr vm = virDomainFindByUUID(&nconn->domains, domain->uuid);
+  assert(vm);
+  virDomainRemoveInactive(&nconn->domains, vm); //vmobjptr unlocked inside function
+  virMutexUnlock(&nconn->lock);
+
+  return 0;
+}
+
+static int domainGetState(virDomainPtr dom, int *state, int *reason, unsigned int flags ATTRIBUTE_UNUSED)
+{
+  virDomainInfo info;
+  if (!state) return -1;
+  if (-1 == domainGetInfo(dom, &info)) return -1;
+
+  *state = info.state;
+  if (reason) *reason = 0;
+
+  return 0;
+}
+
+static int isAlive(virConnectPtr conn ATTRIBUTE_UNUSED)
+{
+  return 1; //alive
+}
+
+static int
+setKeepAlive(virConnectPtr conn ATTRIBUTE_UNUSED, int interval ATTRIBUTE_UNUSED, unsigned int count ATTRIBUTE_UNUSED)
+{
+  return 1; //means unsupported
+}
+
+static int novaVersion(virConnectPtr conn, unsigned long *version) {
+  if (!conn || !version) return -1;
+  *version = NOVA_PROTOCOL_VERSION;
+  return 0;
+}
+
+static int
+domainBlockStats(virDomainPtr domain, const char *disk ATTRIBUTE_UNUSED, virDomainBlockStatsPtr stats)
+{
+  if (!domain || !stats) return -1;
+
+  create_nova_request(domain->conn, NOVA_GET_DISK_INFO, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  struct tmp {
+    uint64_t read;
+    uint64_t read_rq;
+    uint64_t written;
+    uint64_t write_rq;
+    uint64_t errors;
+  } ATTRIBUTE_PACKED * recv_stats = (struct tmp *)(&_in->opspecific);
+
+  stats->rd_req   = be64toh(recv_stats->read_rq);
+  stats->rd_bytes = be64toh(recv_stats->read);
+  stats->wr_req   = be64toh(recv_stats->write_rq);
+  stats->wr_bytes = be64toh(recv_stats->written);
+  stats->errs     = be64toh(recv_stats->errors);
+
+  return 0;
+}
+
+static int
+domainInterfaceStats (virDomainPtr domain, const char *path ATTRIBUTE_UNUSED, virDomainInterfaceStatsPtr stats)
+{
+  if (!domain || !stats) return -1;
+
+  create_nova_request(domain->conn, NOVA_GET_NET_INFO, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  struct tmp {
+    uint64_t rx;
+    uint64_t rx_packets;
+    uint64_t rx_drop;
+    uint64_t tx;
+    uint64_t tx_packets;
+    uint64_t tx_drop;
+  } ATTRIBUTE_PACKED * recv_stats = (struct tmp *)(&_in->opspecific);
+
+  stats->rx_bytes   = be64toh(recv_stats->rx);
+  stats->rx_packets = be64toh(recv_stats->rx_packets);
+  stats->rx_errs    = 0;
+  stats->rx_drop    = be64toh(recv_stats->rx_drop);
+  stats->tx_bytes   = be64toh(recv_stats->tx);
+  stats->tx_packets = be64toh(recv_stats->tx_packets);
+  stats->tx_errs    = 0;
+  stats->tx_drop    = be64toh(recv_stats->tx_drop);
+
+  return 0;
+}
+#ifdef open
+#undef open /* Needed for compiling on Mac */
+#endif
+
+static virDriver novaDriver = {
+    .no = VIR_DRV_NOVA,
+    .name = "NOVA",
+    .open = novaOpen, /* 0.8.8 */
+    .close = novaClose, /* 0.8.8 */
+    .version = novaVersion, /* 0.9.9 */
+    .nodeGetInfo = nodeGetInfo, /* 0.8.0 */
+    .getCapabilities = getCapabilities, /* 0.9.2 */
+    .listDomains = listDomains, /* 0.8.8 */
+    .numOfDomains = numOfDomains, /* 0.8.8 */
+    .domainCreateXML = domainCreateXML, /* 0.9.9 */
+    .domainLookupByID = domainLookupByID, /* 0.8.8 */
+    .domainLookupByUUID = domainLookupByUUID, /* 0.8.8 */
+    .domainLookupByName = domainLookupByName, /* 0.8.8 */
+    .domainSuspend = domainSuspend, /* 0.9.9 */
+    .domainResume = domainResume, /* 0.9.9 */
+    .domainDestroy = domainDestroy, /* 0.8.8 */
+    .domainGetInfo = domainGetInfo, /* 0.8.8 */
+    .domainGetState = domainGetState, /* 0.9.2 */
+    .domainGetXMLDesc = domainGetXMLDesc, /* 0.9.9 */
+    .listDefinedDomains = listDefinedDomains, /* 0.8.8 */
+    .numOfDefinedDomains = numOfDefinedDomains, /* 0.8.8 */
+    .domainCreate = domainCreate, /* 0.8.8 */
+    .domainIsPersistent = domainIsPersistent, /* 0.8.8 */
+    .domainEventRegisterAny = domainEventRegisterAny, /* 0.8.8 */
+    .domainEventDeregisterAny = domainEventDeregisterAny, /* 0.8.8 */
+    .setKeepAlive = setKeepAlive, /* 0.9.9 */
+    .isAlive = isAlive, /* 0.9.9 */
+    .domainBlockStats = domainBlockStats, /* 0.9.9 */
+    .domainInterfaceStats = domainInterfaceStats, /* 0.9.9 */
+};
+
+/**
+ * NOVA Register:
+ *
+ * Registers the NOVA driver
+ */
+int
+novaRegister(void)
+{
+    if (virRegisterDriver(&novaDriver) < 0) return -1;
+    return 0;
+}
diff --git a/src/nova/nova_driver.h b/src/nova/nova_driver.h
new file mode 100644
index 0000000..6dd4954
--- /dev/null
+++ b/src/nova/nova_driver.h
@@ -0,0 +1,18 @@
+/*
+ * Driver to manage VMs running on top of NUL (NOVA user land)
+ * (http://www.tudos.org/nul)
+ *
+ * Copyright (C) 2010-2012 Alexander Boettcher, Operating Systems Group, TU Dresden, Germany
+ *
+ * See COPYING.LIB for the license of this software
+ *
+ * Alexander Boettcher <boettcher@tudos.org>
+ */
+#ifndef __VIR_NOVA_INTERNAL_H__
+# define __VIR_NOVA_INTERNAL_H__
+
+# include "internal.h"
+
+int novaRegister(void);
+
+#endif /* __VIR_NOVA_INTERNAL_H__ */
diff --git a/src/nova/nova_types.h b/src/nova/nova_types.h
new file mode 100644
index 0000000..bf12974
--- /dev/null
+++ b/src/nova/nova_types.h
@@ -0,0 +1,54 @@
+/*
+ * Driver to manage VMs running on top of NUL (NOVA user land)
+ * (http://www.tudos.org/nul)
+ *
+ * Copyright (C) 2010-2012 Alexander Boettcher, Operating Systems Group, TU Dresden, Germany
+ *
+ * See COPYING.LIB for the license of this software
+ *
+ * Alexander Boettcher <boettcher@tudos.org>
+ */
+enum LIBVIRT_NOVA_OPCODE {
+  NOVA_OP_FAILED   = 0x8,
+  NOVA_OP_SUCCEEDED = 0x9,
+  NOVA_OP_FAILED_OUT_OF_MEMORY = 0xa,
+  NOVA_PACKET_LEN  = 0x40,
+  NOVA_NUM_OF_ACTIVE_DOMAINS = 0x20,
+  NOVA_NUM_OF_DEFINED_DOMAINS,
+  NOVA_LIST_ACTIVE_DOMAINS,
+  NOVA_LIST_DEFINED_DOMAINS,
+  NOVA_GET_NAME_ID,
+  NOVA_GET_NAME_UUID,
+  NOVA_GET_NAME,
+  NOVA_GET_VM_INFO,
+  NOVA_VM_START,
+  NOVA_VM_PAUSE,
+  NOVA_VM_RESUME,
+  NOVA_VM_DESTROY,
+  NOVA_UNSUPPORTED_VERSION,
+  NOVA_ENABLE_EVENT,
+  NOVA_DISABLE_EVENT,
+  NOVA_EVENT,
+  NOVA_HW_INFO,
+  NOVA_AUTH,
+  NOVA_ATOMIC_RULE,
+  NOVA_GET_DISK_INFO,
+  NOVA_GET_NET_INFO,
+  EVENT_REBOOT = 0xbbbb,
+  EVENT_UNSERVED_IOACCESS = 0xbbc0,
+  EVENT_DMAR_ACCESS = 0xbbd0,
+  EVENT_VDEV_HONEYPOT = 0xbbd1,
+};
+
+struct incoming_packet {
+  uint16_t version;
+  uint16_t opcode;
+  unsigned char opspecific;
+} __attribute__((packed));
+
+struct outgoing_packet {
+  uint16_t version;
+  uint16_t opcode;
+  uint8_t  result;
+  unsigned char opspecific;
+} __attribute__((packed));
diff --git a/src/util/virterror.c b/src/util/virterror.c
index 380dc56..10b3515 100644
--- a/src/util/virterror.c
+++ b/src/util/virterror.c
@@ -178,6 +178,9 @@ static const char *virErrorDomainName(virErrorDomain domain) {
         case VIR_FROM_CAPABILITIES:
             dom = "Capabilities ";
             break;
+        case VIR_FROM_NOVA:
+            dom = "NOVA ";
+            break;
     }
     return(dom);
 }
